\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{pgf, tikz}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{xcolor}
\usetikzlibrary{arrows, automata}

\title{EC: attacks on current construction}
\author{Henri Stern, Wyatt Daviau}
\date{November 2018}

\definecolor{noteColor}{RGB}{232,196,78}
\newcommand{\note}[1]{\par\noindent\colorbox{noteColor}
{\parbox{\dimexpr\textwidth-2\fboxsep\relax}{#1}}}
\newtheorem{assume}{Assumption}
\newcommand{\ec}{EC A}

\begin{document}

\maketitle

\section{Introduction}
This document exists to keep track of attack ideas, sketches of attacks and (soon!) fully developed attacks on what we term the "current construction".  We are exploring these attacks to help motivate why EC is the way it is, and understand why various plans to modify the protocol are under discussion.

\section{Current Protocol}

This section reflects the construction of EC under which we analyze the attacks below.

\subsection{Candidate Construction \ec{}}
We propose a quick sketch of a plausible construction.

We distinguish between "rounds" and "tipsets." A round takes $\Delta$, the protocol-defined block time. This delay is enforced with a VDF.  At each round 0 or more miners may win an election and the right to extend the chain by 1 block. If 1 or more leaders win election in a round they release their blocks to the network, those blocks collectively forming a "tipset", a link in the blockchain.  If 0 leaders are elected in a round, miners will "mine a null block," running another election off of the losing ticket until a winner is found and a block published. Let tipset S be a tipset generated on top of k null blocks. We define
\begin{itemize}
\item Round (S) -- a function yielding the time at which S was generated
\item Tipset (S) -- a function yielding S's position as a block in the chain
\item Parent(S) -- a function returning the tipset directly before S's
\end{itemize}
We have $\text{Round}(S) = \text{Round(Parent}(S)) + k\Delta$ and $\text{Tipset}(S) = \text{Tipset}(Parent(S)) + 1$.

We distinguish between "seeds" and "tickets".
A seed is outputted from a VDF (with an earlier ticket as input), proving your block generation was appropriately delayed. A ticket is outputted by a VRF (with a seed used as input) and used with the Power Table to prove you are indeed a leader--eligible to generate a block.

In a sense, we have a ticket chain used to elect leaders in consecutive tipsets. It is generated by running past seeds (from $k_l$ back) through a VRF.
We also have a seed chain which enforces the appropriate delay throughout the mining cycle. It is generated by running past tickets (from $k_l$ back) through a VDF.

Seeds $s_{t,0}$ are generated every round.  $s_{t,0} = \text{VDF}(s_{t-1})$.  Tickets are generated from a seed.  $T_{t,i} = \text{VRF}(s_{L(t)}) $.  $L(t) $ is a function going from the current round to a tuple $(\text{round}, i)$ that determines which seed should be input into the VRF.  Seeds with $i > 0$ were updated with a VDF during leader election to make progress in response to an election with 0 leaders.

\subsection{Lookback}
\ec{} uses two lookback parameters $k_{pt}$ and $k_{l}$.  $k_{pt}$ is the number of tipsets back in the chain from which the power table of the head is sampled.  $k_{l}$ is the number of tipsets back in the chain from which the winning ticket is sampled for leader election.  In order to avoid adaptive key generation attacks, where miners adaptively select their public keys in order to influence leader election, we have $k_{pt} > k_{l}$.  

\subsection{Block generation}
Say you are a miner and would like to extend the chain from the tipset at index i, $TS_i$. In order to publish a new block into $TS_{i+1}$, you must be provably elected leader (1) and provably wait a period of $\Delta$ to publish your new block (2).

In order to satisfy (1), we use a seed from $k_l$ tipsets back to generate a new ticket and determine whether we are elected leader.
You take the seed from $TS_{i-k_l}$, we call this seed $S_{i-k_l}$. Check whether you are a leader by generating a new ticket $T_{i+1}$, running VRF($S_{i-k_l}$).
You compare $T_{i+1}$ with your power in the power table at $TS_{i-k_{pt}}$ to determine whether you have been elected in this round.
\begin{enumerate}
\item $T_{i+1}$ a winning ticket, generate a new block including $T_{i+1}$ and publish it.
\item $T_{i+1}$ is a losing ticket, someone else publishes a block. Repeat the above with this new head at $TS_{i+1}$.
\item $T_{i+1}$ is a losing ticket, no one else publishes a block in the round. You use the losing ticket to mine a "null block" running VRF($T_{i+1}$) to generate a new ticket, $T_{i+1}'$. Repeat the above comparison with this new ticket.
\end{enumerate}

In order to satisfy (2) we must generate as many successive VDF proofs as we do tickets.
\begin{enumerate}
\item To generate a winning ticket from a published block in $TS_{i}$, include $S_i'$ = VDF($S_i$) in your new block.
\item To generate a winning ticket from a losing ticket (mining a null block), run a VDF on your VDF output, VDF($S_i'$) and include it in your new block.
\end{enumerate}

\subsection{Weighting Function and tipset choice}
We aim to make the assumption of $k_l$ local predictability clear in the exploration of these attacks so that we can immediately compare this construction to other constructions that do away with the $k_l$ predictability (i.e. the 2 VDF ideas from aq issue 98).

Multiple parents (i.e. tipsets), null blocks whose tickets can't be shared among miners, tickets derived from signature of hash of previous ticket (as in Algorand), previous ticket comes from previous block.  Weighting function simplified version of that in spec: each non-null block adds weight $w = C $, where $ C $ is just some constant .  Ties are broken by smallest min ticket in a tipset. 

\subsection{Things to Pin Down}
\begin{itemize}
    \item Weighting function, as in spec including power term, innovations including storage capacity etc
    \item Should ticket chain include VRFs in between successive rounds?  If not the seed chain is essentially a unhinged VDF chain running forever.  Drift and some miners speeding up the VDF might make this vulnerable.  If instead we mix the VRF of the winner in with the seed then the seed chain cannot be generated in advance.  We also regain the whole "min ticket" idea in the current spec.
    \item 
    Should there be VDFs between seeds generated to during null block events?  The extra predictability from only running VRFs among multiple tickets might be acceptable as delay is already enforced by the delay proof.
\end{itemize}

\section{Threat Model}

\subsection{Assumptions}
\begin{enumerate}
    \item Rational adversary and otherwise honest participants.
    \item Adversary tries to increase her odds of being elected leader in a given round beyond the fair proportion dictated by the power she has committed to the network.
    \item The adversary alone mines on forks that are not the heaviest.
    \item The adversary may withhold blocks or mine in a secret fork.
    \item The adversary experiences no network delay and can rush.
    \item The adversary does not control network delay for other participants.
\end{enumerate}

\subsection{Future Work (TODO)}
\begin{itemize}
\item Variation of the above where the adversary has the power to eclipse sets of honest participants.
\end{itemize}
    
\subsection{Notes on our process}

For each attack below, we seek to:
\begin{enumerate} 
    \item Start with *some* strategy for an adversary to gain an advantage (or attack) and describe it in some detail
    \item Create a simple model to evaluate adversary's performance in this model. 
\end{enumerate}
    
We then use this to revisit assumptions about our construction. We can then alter the construction and repeat for each attack, or modify the attacker and repeat for each attack.

\section{Motifs}
\begin{itemize}
   \item The adversary has power $\alpha$.
\item We will talk about "density" below as shorthand for weight of a chain divided by the weight of a chain of the same epoch length with 1 block per epoch.  When all miners mine on a chain in EC the expected density is 1.
\end{itemize}


\section{Attacks}

\subsection{Block Withholding Attack}

\subsubsection{Assumptions and Definitions}
The following is an initial worst case analysis of EC A's susceptibility to selfish mining attacks.  Note that the following probability analysis does not include reasoning about expected rewards of the attacker and therefore extends without modifications to purely online attacks against modified versions of EC that are not predictable.

The idea here is to put an upper bound on the attacker's probability of success without getting too technical.  We can achieve decent guarantees against long range forks, i.e. of more than a few hours of blocks, and against weak attackers, i.e. less than $\frac{1}{100}$ of network's power.

The following analysis does not make any assumptions about distribution of mining power.  It uses a standard chernoff bound when considering all miner elections as Bernoulli trials with probability of success equal to network power.  It uses a simplified model of the weighting function where each block has a constant weight and there is not leader-power term added in.  (TODO extend analysis to include the leader-power term).  We assume independence of leader elections in each round throughout.  In places we assume that the attacker's probability of success is higher than it actually is.  If this style of analysis seems fruitful there are places that bounds could be tightened down by getting more technical, i.e. making arguments about $m$ of $n$ successes in the poisson binomial distribution, likely aided by making more assumptions about the distribution of honest mining power.

\subsubsection{Spec}
The attack proceeds as follows.  The attacker attempts to mine a private fork over $n$ rounds with a greater weight than the honest fork.  The attacker mines such a fork (terminating in a non-null block) and releases to the rest of the network.  This achieves:
\begin{enumerate}
    \item 
    The attacker's proportion of the rewards is relatively higher than if it had followed the EC A protocol honestly
    \item
    The attacker can mine around $n$ rounds of honest activity, for example using this to double spend
\end{enumerate}Because EC A is $k_l$ predictable the attacker can know in advance how many $m$ leader elections it wins out of $n$ possible blocks.  And it need not run this algorithm online for $n \leq k_l$.  For $n \geq k_l$ the attacker will need to run an online variant as in classical PoW selfish mining.

\subsubsection{Analysis}
First we consider the probability $\Omega_{n,m}$ that at any round the attacker wins $m$ out of $n$ elections while winning the final election.  The final condition is key as the attacker cannot propagate a null block at the end of the attack.  This is just the probability of winning the $n$th round and winning $m-1$ out of the $n-1$ remaining rounds:
$$
\Omega_{n,m} = \binom{n-1}{m-1}\alpha^m (1-\alpha)^{n-m}
$$

Second, we consider the probability $S_{n,m}$ that the honest chain is no more dense than the attacker chain given that the attacker wins $m$ out of $n$ rounds.  We give the attacker the min ticket tie-break in order to avoid analyzing different distributions of honest miners and say that the attacker wins with probability equal to the probability that the honest chain wins the same amount or fewer blocks.

To bound this probability $S_{n,m}$ we give the attacker victory with probability 1 when the attacker's chain has more election wins than the expected number of election wins in the honest chain, i.e. when $m > n(1-\alpha)$.  In other cases we bound the attacker's winning probability with the standard chernoff bound.  Let $X$ be the random variable taking on the number of blocks won in $n$ rounds on the honest chain.
\begin{align*}
    S_{n,m} = \text{Pr}[X \leq m = (1-\delta)\mu]&=e^{-\frac{\mu \delta^2}{2}}\\
    \text{where}\\
    &\delta = 1 - \frac{m}{n(1-\alpha)}\\
    &\mu = (1 - \alpha)n\\
\end{align*}

Therefore in each round the attacker could win a fork of length $n$ by following the withholding strategy with probability no more than 
$$
\sum_m \Omega_{n,m} S_{n,m}
$$
Note that the events behind $\Omega_{n,m}$ are all disjoint, so this summation does not loosen the bound.  So far the approximation comes from the lack of tightness of Chernoff bound / assuring attacker success when density of attacking chain is higher than expectation of honest chain density.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=4in]{big-probs.png}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=4in]{small-probs.png}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=4in]{small-probs-low.png}
\end{figure}


\subsubsection{Future Work}
\begin{enumerate}
    \item 
    Visualize probability of success as a function of fork size / fork density
    \item
    Get a bound on probability of attacker being able to successfully fork at least some number of rounds.
    \item
    Visualize expected number of events with probability of success over $\epsilon$ for a given chain length (i.e. a year).
    \item
    Calculated expected return
    \item
    Look into effects of online vs offline witholding strategies.  This could directly impact choice to modify predictability of construction.  In particular if the protocol is less predictable it will be much harder for the attacker to determine when/if they should start witholding.
    \item
    Determine bounds on security parameters $k_{pt}$ and $k_l$ based on likelihood of forking chains of a certain length.
\end{enumerate}

\subsection{Block Withholding to Seed Biasing}

\subsubsection{Sketch}
Block withholding adversaries make long forks that can reorg history.  Such an ability could potentially be used for biasing the seed, see the key to the city attack in section 3.  The analysis in that section is less precise that the analysis in section 6 and.  In light of the bounds in section 6 it is possible for an adversary of a certain power to mine a private fork with a heavier weight.  

%Using a delay function between every block as proposed in construction EC A limits seed biasing further than the limits explored in section 3.  After successfully mining a private fork $\geq k_{pt}$ the adversary CAN grind a public key included $k_{pt}$ blocks back, however to simulate an identity that wins multiple elections it needs to run multiple VDFs.  It can only accomplish this by 1. Having delayed the honest chain (I think this involves the adversary getting slashed or very lucky) or 2. Giving up some of its private fork weight so that it can get a few extra VDF calls in (i.e. needs to mine longer forks to get 

In broad strokes this is the attack I want to explore further.  An attacker can see $k_l$ blocks into the future.  The attacker runs an online until it has a private fork of length $\geq k_{pt} - k_l$.  At this point the attacker can determine the success probability of continuing the private fork another $k_l$ blocks.  If the odds are in the attacker's favor it can grind through many keys, looking for identities that will win in $k_l$ blocks (using the latest private ticket in the chain as input per the protocol).  The attacker can then run all these keys through a VDF... nope it can't see that seed until it has the parent of the block in $k_l - 1$ blocks

Realizing that there is still grinding potential, i.e. by choosing particular forks miners can improve the odds that they get elected $k_{pt}$ in the future.  Should investigate how much of an issue this is.

\subsection{VDF Interruption}

\subsubsection{Sketch}
Attackers can release blocks late in an attempt to get honest miners to restart the mining process on top of the heaviest chain.  This could give the miner a cumulative headstart in running the VDF.  

\end{document}




